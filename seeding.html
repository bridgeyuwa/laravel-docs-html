<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="database-seeding">Database: Seeding</h1>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#writing-seeders">Writing Seeders</a>
<ul>
<li><a href="#using-model-factories">Using Model Factories</a></li>
<li><a href="#calling-additional-seeders">Calling Additional Seeders</a></li>
</ul></li>
<li><a href="#running-seeders">Running Seeders</a></li>
</ul>
<p><a name="introduction"></a> ## Introduction</p>
<p>Laravel includes a simple method of seeding your database with test data using seed classes. All seed classes are stored in <code>database/seeds</code>. Seed classes may have any name you wish, but probably should follow some sensible convention, such as <code>UsersTableSeeder</code>, etc. By default, a <code>DatabaseSeeder</code> class is defined for you. From this class, you may use the <code>call</code> method to run other seed classes, allowing you to control the seeding order.</p>
<p><a name="writing-seeders"></a> ## Writing Seeders</p>
<p>To generate a seeder, you may issue the <code>make:seeder</code> <a href="/docs/%7B%7Bversion%7D%7D/artisan">Artisan command</a>. All seeders generated by the framework will be placed in the <code>database/seeds</code> directory:</p>
<pre><code>php artisan make:seeder UsersTableSeeder</code></pre>
<p>A seeder class only contains one method by default: <code>run</code>. This method is called when the <code>db:seed</code> <a href="/docs/%7B%7Bversion%7D%7D/artisan">Artisan command</a> is executed. Within the <code>run</code> method, you may insert data into your database however you wish. You may use the <a href="/docs/%7B%7Bversion%7D%7D/queries">query builder</a> to manually insert data or you may use <a href="/docs/%7B%7Bversion%7D%7D/testing#model-factories">Eloquent model factories</a>.</p>
<p>As an example, let's modify the <code>DatabaseSeeder</code> class which is included with a default installation of Laravel. Let's add a database insert statement to the <code>run</code> method:</p>
<pre><code>&lt;?php

use Illuminate\Database\Seeder;
use Illuminate\Database\Eloquent\Model;

class DatabaseSeeder extends Seeder
{
    /**
     * Run the database seeds.
     *
     * @return void
     */
    public function run()
    {
        DB::table(&#39;users&#39;)-&gt;insert([
            &#39;name&#39; =&gt; str_random(10),
            &#39;email&#39; =&gt; str_random(10).&#39;@gmail.com&#39;,
            &#39;password&#39; =&gt; bcrypt(&#39;secret&#39;),
        ]);
    }
}</code></pre>
<p><a name="using-model-factories"></a> ### Using Model Factories</p>
<p>Of course, manually specifying the attributes for each model seed is cumbersome. Instead, you can use <a href="/docs/%7B%7Bversion%7D%7D/testing#model-factories">model factories</a> to conveniently generate large amounts of database records. First, review the <a href="/docs/%7B%7Bversion%7D%7D/testing#model-factories">model factory documentation</a> to learn how to define your factories. Once you have defined your factories, you may use the <code>factory</code> helper function to insert records into your database.</p>
<p>For example, let's create 50 users and attach a relationship to each user:</p>
<pre><code>/**
 * Run the database seeds.
 *
 * @return void
 */
public function run()
{
    factory(App\User::class, 50)-&gt;create()-&gt;each(function($u) {
        $u-&gt;posts()-&gt;save(factory(App\Post::class)-&gt;make());
    });
}</code></pre>
<p><a name="calling-additional-seeders"></a> ### Calling Additional Seeders</p>
<p>Within the <code>DatabaseSeeder</code> class, you may use the <code>call</code> method to execute additional seed classes. Using the <code>call</code> method allows you to break up your database seeding into multiple files so that no single seeder class becomes overwhelmingly large. Simply pass the name of the seeder class you wish to run:</p>
<pre><code>/**
 * Run the database seeds.
 *
 * @return void
 */
public function run()
{
    Model::unguard();

    $this-&gt;call(UsersTableSeeder::class);
    $this-&gt;call(PostsTableSeeder::class);
    $this-&gt;call(CommentsTableSeeder::class);
    
    Model::reguard();
}</code></pre>
<p><a name="running-seeders"></a> ## Running Seeders</p>
<p>Once you have written your seeder classes, you may use the <code>db:seed</code> Artisan command to seed your database. By default, the <code>db:seed</code> command runs the <code>DatabaseSeeder</code> class, which may be used to call other seed classes. However, you may use the <code>--class</code> option to specify a specific seeder class to run individually:</p>
<pre><code>php artisan db:seed

php artisan db:seed --class=UserTableSeeder</code></pre>
<p>You may also seed your database using the <code>migrate:refresh</code> command, which will also rollback and re-run all of your migrations. This command is useful for completely re-building your database:</p>
<pre><code>php artisan migrate:refresh --seed</code></pre>
</body>
</html>
